structure Utils =
struct

exception ERR string string;

fun stub s = raise ERR s "stub";

fun total f x = Some (f x) handle _ => None;

fun assert b s = if b then () else raise ERR s "assertion failure";

val debugLevel = Ref 0;

fun print s = if !debugLevel < 1 then () else TextIO.print s;

fun println s = print (s^"\n");

fun cons h t = h::t;

fun first pred list =
 case list
  of [] => raise ERR "first" ""
   | h::t => if pred h then h else first pred t;

fun quote s = String.concat ["\"",s,"\""];

fun take_drop n list =
 if n <= List.length list
  then Some(List.take list n,List.drop list n)
  else None;

fun front_last list =
 let val _ = assert (not (List.null list)) "front_last: null input list"
     fun flacc l acc =
      case l
       of [x] => (List.rev acc,x)
        | h::t => flacc t (h::acc)
 in flacc list []
 end

val w8char = Char.chr o Word8.toInt;
val charw8 = Word8.fromInt o Char.ord;

fun divmod i n = (Int.div i n, Int.mod i n);

fun rev_itlist f list acc =
 case list
  of [] => acc
   | h::t => rev_itlist f t (f h acc);

fun itlist f list b =
 case list
  of [] => b
   | h::t => f h (itlist f t b);

fun upto lo hi = if lo > hi then [] else lo::upto(lo+1) hi;

fun mapArray f array =
  let val elts = Array.foldr cons [] array
  in List.map f elts
  end;

fun mapByteArray f array =
  let val top = Word8Array.length array
      fun itFn i acc =
          if i < top then
	     itFn (i+1) (f (Word8Array.sub array i)::acc)
          else List.rev acc
  in itFn 0 []
  end;

fun firstOpt f list =
 case list
  of [] => None
   | h::t =>
 case f h
  of None => firstOpt f t
   | Some x => Some h;

fun concatOpts optlist =
    Some(List.concat(List.map Option.valOf optlist)) handle _ => None;

fun strcatOpts optlist =
    Some(String.concat(List.map Option.valOf optlist)) handle _ => None;

fun filterOpt pred list = let
   fun accFn list acc =
    case list
     of [] => Some (List.rev acc)
      | h::t =>
        case pred h
         of None => None
          | Some True => accFn t (h::acc)
          | Some False => accFn t acc
 in
   accFn list []
 end;

(*---------------------------------------------------------------------------*)
(* move from 'a option option to 'a option                                   *)
(*---------------------------------------------------------------------------*)

fun dropOpt errstring optOpt =
 case optOpt
  of None => None
   | Some(Some x) => Some x
   | Some None => raise ERR "dropOpt" errstring;

fun pow b k =
 let fun accFn k acc = if k <= 0 then acc else accFn (k-1) (acc * b)
 in accFn k 1
 end

local
   val pow2Arr = Array.fromList (List.map (pow 2) (upto 0 512));
in
fun twoExp n = Array.sub pow2Arr n handle _ => pow 2 n
end;

val w8zero = Word8.fromInt 0;
val w64FF = Word64.fromInt 255;

fun bytes2string bytes = String.implode (List.map w8char bytes);

fun byte_array_fromList list =
 let val arr = Word8Array.array (List.length list) w8zero
     fun appFn i list =
        case list
         of [] => ()
          | h::t => (Word8Array.update arr i h; appFn (i+1) t)
 in appFn 0 list;
    arr
 end;

val emptybuf = Word8Array.array 0 w8zero;
val singlebuf = Word8Array.array 1 (Word8.fromInt 0);

fun clear_buf buffer =
 let val len = Word8Array.length buffer
     fun zero i = Word8Array.update buffer i w8zero
     fun loop j = if j < len then (zero j; loop (j+1)) else ()
 in
    loop 0
 end;

fun buf2string buf = Word8Array.substring buf 0 (Word8Array.length buf);

fun string2buf s buf =
 if String.size s <= Word8Array.length buf then
   Word8Array.copyVec s 0 (String.size s) buf 0
 else
   raise ERR "string2buf" "string too big for buffer";

fun file2buf fileName buf =
    let val istrm = TextIO.openIn fileName
        val () = print(String.concat
                     ["Taking input from file : ",fileName,".\n"])
        val s = TextIO.inputAll istrm
        val () = TextIO.closeIn istrm
    in
       string2buf s buf
    end

fun tilde_to_uminus ch = if ch = #"~" then #"-" else ch;

fun i2d i =
 let val s = Int.toString i
     val s' = String.translate tilde_to_uminus s
 in
  Double.fromString (s' ^ ".0")
 end

fun array_existsI pred arr =
 let val len = Array.length arr
 in if len = 0 then False
    else List.exists pred (upto 0 (len - 1))
 end

fun copies x n = if n <= 0 then [] else x::copies x (n-1);

fun boolVal n =
  if n = 0 then False else
  if n = 1 then True
  else raise ERR "boolVal" "";

fun byteAt w n =
  Word8.fromInt
    (Word64.toInt
      (Word64.andb (Word64.>> w (n*8)) w64FF));

fun pack_double buf index d =
 let fun write n x = Word8Array.update buf n x
 in
    write index (byteAt d 0)
  ; write (index+1) (byteAt d 1)
  ; write (index+2) (byteAt d 2)
  ; write (index+3) (byteAt d 3)
  ; write (index+4) (byteAt d 4)
  ; write (index+5) (byteAt d 5)
  ; write (index+6) (byteAt d 6)
  ; write (index+7) (byteAt d 7)
 end;

fun unpack_double buf index =
 let fun elt n = Word8Array.sub buf n
 in  Word64.concatAll
       (elt index)     (elt (index+1)) (elt (index+2)) (elt (index+3))
       (elt (index+4)) (elt (index+5)) (elt (index+6)) (elt (index+7))
 end;

fun int2octal n =
let fun divAcc n acc =
      if n < 8 then n::acc
      else let val (d,r) = divmod n 8 in divAcc d (r::acc) end
in String.concat
        (List.map Int.toString (divAcc n []))
end

fun pack_u8 n = String.str (Char.chr n);

fun pad_left x n list =
 let val d = n - List.length list
     val _ = assert (d >= 0) "pad_left: list too long"
 in copies x d @ list
 end

fun divAcc n acc =
 if n < 256 then n::acc
 else
   let val (d,r) = divmod n 256 in divAcc d (r::acc) end

fun pack_u16 n =
let val ilist = pad_left 0 2 (divAcc n [])
in
  String.implode (List.map Char.chr ilist)
end

fun pack_u32 n =
let val ilist = pad_left 0 4 (divAcc n [])
in
  String.implode (List.map Char.chr ilist)
end

fun pack_u64 n =
let val ilist = pad_left 0 8 (divAcc n [])
in
  String.implode (List.map Char.chr ilist)
end

fun pack_u16LE n =
let val ilist = pad_left 0 2 (divAcc n [])
in
  String.implode
    (List.map Char.chr (List.rev ilist))
end

fun pack_u32LE n =
let val ilist = pad_left 0 4 (divAcc n [])
in
  String.implode
     (List.map Char.chr (List.rev ilist))
end

fun pack_u64LE n =
let val ilist = pad_left 0 8 (divAcc n [])
in
  String.implode
    (List.map Char.chr (List.rev ilist))
end

fun pack_byte_array bA = Word8Array.substring bA 0 (Word8Array.length bA);

fun unsignedBE bytes =
 let fun accFn list acc =
         case list
          of [] => acc
           | byte::t => accFn t (Word8.toInt byte + 256 * acc)
 in accFn bytes 0
 end

fun twos_compBE bytes =
 let val sup = twoExp (List.length bytes)
     val half = sup div 2
     val n = unsignedBE bytes
  in
    if n < half then n else n - sup
 end;

fun unsignedLE bytes = unsignedBE (List.rev bytes)
fun twos_compLE bytes = twos_compBE (List.rev bytes)

(*---------------------------------------------------------------------------*)
(* Have to implement Double on ARM8 by going through C calls.                *)
(*---------------------------------------------------------------------------*)

fun double_negate n =
  let val buf = Word8Array.array 8 (Word8.fromInt 0)
      val _ = pack_double buf 0 n
      val s = Word8Array.substring buf 0 8
      val _ = #(DoubleNeg) s buf
      val r = unpack_double buf 0
  in
    r
  end;

fun double_add lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleAdd) s buf
      val r = unpack_double buf 0
  in
    r
  end;

fun double_sub lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleSub) s buf
      val r = unpack_double buf 0
  in
    r
  end;

fun double_mult lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleMult) s buf
      val r = unpack_double buf 0
  in
    r
  end;

fun double_div lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleDiv) s buf
      val r = unpack_double buf 0
  in
    r
  end;

fun double_eq lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleEQ) s buf
      val r = boolVal (Word8.toInt (Word8Array.sub buf 0))
  in
    r
  end;

fun double_lt lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleLT) s buf
      val r = boolVal (Word8.toInt (Word8Array.sub buf 0))
  in
    r
  end;

fun double_gt lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleGT) s buf
      val r = boolVal (Word8.toInt (Word8Array.sub buf 0))
  in
    r
  end;

fun double_lte lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleLE) s buf
      val r = boolVal (Word8.toInt (Word8Array.sub buf 0))
  in
    r
  end;

fun double_gte lop rop =
  let val buf = Word8Array.array 16 (Word8.fromInt 0)
      val _ = pack_double buf 0 lop
      val _ = pack_double buf 8 rop
      val s = Word8Array.substring buf 0 16
      val _ = #(DoubleGE) s buf
      val r = boolVal (Word8.toInt (Word8Array.sub buf 0))
  in
    r
  end;


end (* Utils *)


structure ByteContig =
struct

datatype lval
  = VarName string
  | RecdProj lval string
  | ArraySub lval exp
and exp
  = Loc lval
  | IntLit int
  | ConstName string
  | Add exp exp
  | Mult exp exp
;

datatype bexp
  = BoolLit bool
  | BLoc lval
  | Bnot bexp
  | Bor  bexp bexp
  | Band bexp bexp
  | Beq  exp exp
  | Blt  exp exp
  | Bgt  exp exp
  | Ble  exp exp
  | Bge  exp exp
  | DleA Double.double exp
  | DleB exp Double.double
;

datatype atom
  = Bool
  | Char
  | Float
  | Double
  | Signed int
  | Unsigned int
  | Blob;


datatype contig
  = Void
  | Basic atom
  | Declared string
  | Raw exp
  | Assert bexp
  | Recd ((string * contig) list)
  | Array contig exp
  | Union ((bexp * contig) list)

datatype ptree
  = LEAF atom (Word8.word list)
  | RECD ((string * ptree) list)
  | ARRAY (ptree list)
;

datatype ('a,'b) verdict = PASS 'a | FAIL 'b;

fun lval_to_string lval =
 case lval
  of VarName s => s
   | RecdProj lval s => lval_to_string lval^"."^s
   | ArraySub lval (IntLit i) => lval_to_string lval^"["^Int.toString i^"]"

(*---------------------------------------------------------------------------*)
(* Support for lval-map                                                      *)
(*---------------------------------------------------------------------------*)

fun lval_compare x y =
 case (x,y)
  of (VarName s1, VarName s2) => String.compare s1 s2
   | (VarName _, _) => Less
   | (RecdProj a b, VarName _) => Greater
   | (RecdProj e1 s1,RecdProj e2 s2) =>
       (case lval_compare e1 e2
         of Equal => String.compare s1 s2
	  | other => other)
   | (RecdProj a b,_) => Less
   | (ArraySub a b, ArraySub c d) =>
       (case lval_compare a c
         of Equal => exp_compare b d
	  | other => other)
   | (ArraySub a b, _) => Greater
and
 exp_compare x y =
 case (x,y)
  of (Loc lv1, Loc lv2) => lval_compare lv1 lv2
   | (Loc lv1, _) => Less
   | (IntLit _, Loc _) => Greater
   | (IntLit i, IntLit j) => Int.compare i j
   | (IntLit i, other) => Less
   | (ConstName _, Loc _) => Greater
   | (ConstName _, IntLit _) => Greater
   | (ConstName s1, ConstName s2) => String.compare s1 s2
   | (ConstName s, _) => Less
   | (Add a b, Mult c d) => Less
   | (Add a b, Add c d) =>
       (case exp_compare a c
         of Equal => exp_compare b d
	  | other => other)
   | (Add a b, _) => Greater
   | (Mult a b, Mult c d) =>
       (case exp_compare a c
         of Equal => exp_compare b d
	  | other => other)
   | (Mult a b, _) => Greater
;

(*---------------------------------------------------------------------------*)
(* Map from lvals to (atom,(offset,width)) pairs, where atom signals what    *)
(* kind of type the string between offset and offset+width should be         *)
(* interpeted as.                                                            *)
(*---------------------------------------------------------------------------*)

fun empty_lvalMap() = Map.empty lval_compare;

fun unopFn f g e = Option.map f (g e);

fun binopFn f g e1 e2 =
  case (g e1, g e2)
   of (Some v1, Some v2) => Some (f v1 v2)
    | otherwise => None;

fun total_bytes_of arr i w =
 let val top = i+w
     fun accFn n acc =
       if n < top then accFn (n+1) (Word8Array.sub arr n::acc)
       else List.rev acc
 in if top <= Word8Array.length arr
    then Some (accFn i [])
    else None
 end;


fun evalExp env bytes =
 let val (envDelta,lvalMap,valFn) = env
     fun locVal (a,(i,width)) =
         Option.mapPartial (valFn a)
           (total_bytes_of bytes i width)
   fun evalE exp =
    case exp
     of Loc lval => Option.mapPartial locVal (Map.lookup lvalMap lval)
      | IntLit i => Some i
      | ConstName s =>
          (case Alist.lookup envDelta s
            of Some i => i
             | None => None)
      | Add e1 e2  => binopFn Int.+ evalE e1 e2
      | Mult e1 e2 => binopFn Int.* evalE e1 e2
 in
   evalE
 end
;

fun equal x y = (x = y);
fun orOp x y = (x orelse y);
fun andOp x y = (x andalso y);

fun evalBexp env bytes =
 let val (envDelta,lvalMap,valFn,dvalFn) = env
     val evalE = evalExp (envDelta,lvalMap,valFn) bytes
     fun blocVal tuple =
       case tuple
        of (Bool,(i,width)) =>
             Option.map Utils.boolVal
              (Option.mapPartial (valFn Bool)
                (total_bytes_of bytes i width))
         | otherwise => None
   fun evalB bexp =
    case bexp
     of BoolLit b => Some b
      | BLoc lval => Option.mapPartial blocVal (Map.lookup lvalMap lval)
      | Bnot b     => Option.map not (evalB b)
      | Bor  b1 b2 => binopFn orOp evalB b1 b2
      | Band b1 b2 => binopFn andOp evalB b1 b2
      | Beq e1 e2  => binopFn equal evalE e1 e2
      | Blt e1 e2  => binopFn Int.< evalE e1 e2
      | Bgt e1 e2  => binopFn Int.> evalE e1 e2
      | Ble e1 e2  => binopFn Int.<= evalE e1 e2
      | Bge e1 e2  => binopFn Int.>= evalE e1 e2
      | otherwise  => None
 in
  evalB
 end;


fun lval_append p lval =
 case lval
  of VarName s => RecdProj p s
   | RecdProj q s => RecdProj (lval_append p q) s
   | ArraySub q dim => ArraySub (lval_append p q) dim
;

fun path_prefixes lval =
 case lval
  of VarName _ => [lval]
   | RecdProj p s => lval :: path_prefixes p
   | ArraySub (VarName _) d => [lval]
   | ArraySub (RecdProj p s) dim => lval :: path_prefixes p
   | ArraySub arr dim => lval :: path_prefixes arr
;

fun resolve_lval lvalMap path lval =
 let val prefixes = path_prefixes path
     val prospects = List.map (flip lval_append lval) prefixes @ [lval]
 in Utils.firstOpt (Map.lookup lvalMap) prospects
 end

fun mk_Loc x = Loc x;
fun mk_Add x y = Add x y;
fun mk_Mult x y = Mult x y;

fun resolveExp lvalMap p exp =
 case exp
  of Loc lval   => unopFn mk_Loc (resolve_lval lvalMap p) lval
   | Add  e1 e2 => binopFn mk_Add (resolveExp lvalMap p) e1 e2
   | Mult e1 e2 => binopFn mk_Mult (resolveExp lvalMap p) e1 e2
   | otherwise  => Some exp


fun mk_BLoc x = BLoc x
fun mk_Bnot x = Bnot x
fun mk_Bor x y = Bor x y
fun mk_Band x y = Band x y
fun mk_Beq x y = Beq x y
fun mk_Blt x y = Blt x y
fun mk_Bgt x y = Bgt x y
fun mk_Ble x y = Ble x y
fun mk_Bge x y = Bge x y
fun mk_dleA r1 r2 = DleA r1 r2;
fun mk_dleB r1 r2 = DleB r1 r2;

fun resolveBexp lvalMap p bexp =
 case bexp
  of BoolLit _  => Some bexp
   | BLoc lval  => unopFn mk_BLoc (resolve_lval lvalMap p) lval
   | Bnot b     => unopFn mk_Bnot(resolveBexp lvalMap p) b
   | Bor b1 b2  => binopFn mk_Bor(resolveBexp lvalMap p) b1 b2
   | Band b1 b2 => binopFn mk_Band(resolveBexp lvalMap p) b1 b2
   | Beq e1 e2  => binopFn mk_Beq(resolveExp lvalMap p) e1 e2
   | Blt e1 e2  => binopFn mk_Blt(resolveExp lvalMap p) e1 e2
   | Bgt e1 e2  => binopFn mk_Bgt(resolveExp lvalMap p) e1 e2
   | Ble e1 e2  => binopFn mk_Ble(resolveExp lvalMap p) e1 e2
   | Bge e1 e2  => binopFn mk_Bge(resolveExp lvalMap p) e1 e2
   | DleA r e   => unopFn (mk_dleA r) (resolveExp lvalMap p) e
   | DleB e r   => unopFn (fn x => mk_dleB x r) (resolveExp lvalMap p) e
;

(*---------------------------------------------------------------------------*)
(* substFn is given an assignment for a contig and applies it to the contig, *)
(* yielding a string.                                                        *)
(*---------------------------------------------------------------------------*)

fun substFn env byteArr theta path contig =
 let val (consts,decls,atomWidth,valFn,dvalFn) = env
     fun thetaFn lval =
         (case Map.lookup theta lval
           of None => None
            | Some (a,(i,width)) =>
                Option.map Utils.bytes2string
	            (total_bytes_of byteArr i width))
 in
  case contig
   of Void     => None
    | Basic _  => thetaFn path
    | Raw _    => thetaFn path
    | Assert b =>
       (case resolveBexp theta path b
         of None => None
          | Some b' =>
        case evalBexp (consts,theta,valFn,dvalFn) byteArr b'
         of Some true => Some ""
          | otherwise => None)
    | Declared name => Option.mapPartial (substFn env byteArr theta path)
                                         (Alist.lookup decls name)
    | Recd fields =>
       let fun fieldFn (fName,c) = substFn env byteArr theta (RecdProj path fName) c
       in Utils.strcatOpts (List.map fieldFn fields)
       end
    | Array c exp =>
       (case resolveExp theta path exp
         of None => None
          | Some exp' =>
        let val dim = Option.valOf (evalExp (consts,theta,valFn) byteArr exp')
            fun indexFn i = substFn env byteArr theta (ArraySub path (IntLit i)) c
        in Utils.strcatOpts (List.map indexFn (Utils.upto 0 (dim - 1)))
        end)
   | Union choices =>
       let fun choiceFn(bexp,c) =
             Option.mapPartial
               (evalBexp (consts,theta,valFn,dvalFn) byteArr)
               (resolveBexp theta path bexp)
       in case Utils.filterOpt choiceFn choices
           of Some [(_,c)] => substFn env byteArr theta path c
            | otherwise => None
       end
end
;

fun fieldFn path (fName,c) = (RecdProj path fName, c)
fun indexFn path c i = (ArraySub path (IntLit i),c)

fun matchFn env byteArr state =
 let val (worklist,pos,theta) = state
     val (consts,decls,atomWidth,valFn,dvalFn) = env
     val arrlen = Word8Array.length byteArr
 in
 case worklist
  of [] => Some (pos,theta)
   | (_,Void)::_ => None
   | (path,Basic a)::t =>
     let val width = atomWidth a
         val nextpos = pos + width
     in if arrlen < nextpos then
          None
        else
          matchFn env byteArr (t,nextpos,Map.insert theta path (a,(pos,width)))
     end
   | (path,Declared name)::t =>
       (case Alist.lookup decls name
        of None => None
	 | Some c => matchFn env byteArr ((path,c)::t,pos,theta))
   | (path,Raw exp)::t =>
       (case resolveExp theta path exp
         of None => None
          | Some exp' =>
        case evalExp (consts,theta,valFn) byteArr exp'
         of None => None
          | Some width =>
        let val nextpos = pos + width
        in if arrlen < nextpos then
              None
            else
              matchFn env byteArr
                  (t,nextpos, Map.insert theta path (Blob,(pos,width)))
        end)
   | (path,Assert bexp)::t =>
       (case resolveBexp theta path bexp
        of None => None
         | Some bexp' =>
        case evalBexp (consts,theta,valFn,dvalFn) byteArr bexp'
         of None => None
          | Some False => None
          | Some True => matchFn env byteArr (t,pos,theta))
   | (path,Recd fields)::t =>
         matchFn env byteArr (List.map (fieldFn path) fields @ t,pos,theta)
   | (path,Array c exp)::t =>
       (case resolveExp theta path exp
         of None => None
          | Some exp'=>
        case evalExp (consts,theta,valFn) byteArr exp'
         of None => None
          | Some dim =>
        matchFn env byteArr
           (List.map (indexFn path c) (Utils.upto 0 (dim - 1)) @ t,pos,theta))
   | (path,Union choices)::t =>
       let fun choiceFn(bexp,c) =
             Option.mapPartial
                (evalBexp (consts,theta,valFn,dvalFn) byteArr)
                (resolveBexp theta path bexp)
       in case Utils.filterOpt choiceFn choices
           of Some[(_,c)] => matchFn env byteArr ((path,c)::t,pos,theta)
            | otherwise => None
       end
 end
;

fun match env contig byteArr =
  matchFn env byteArr ([(VarName"root",contig)],0,empty_lvalMap());

(*
fun check_match env contig byteArr =
 case match env contig byteArr
  of None => raise ERR "check_match" "no match"
  |  Some(pos,theta) =>
      case substFn env byteArr theta (VarName"root") contig
       of Some bits => (s1^s2 = s)
       |  None => raise ERR "check_match" "substFn failed"
*)

(*---------------------------------------------------------------------------*)
(* Version of matchFn that checks assertions, acting as a predicate on       *)
(* messages.                                                                 *)
(*---------------------------------------------------------------------------*)

fun predFn env byteArr state =
 let val (worklist,pos,theta) = state
     val (consts,decls,atomWidth,valFn,dvalFn) = env
     val arrlen = Word8Array.length byteArr
 in
 case worklist
  of [] => PASS (pos,theta)
   | (path,Void)::t => FAIL state
   | (path,Basic a)::t =>
     let val width = atomWidth a
         val nextpos = pos + width
     in if arrlen < nextpos then
           FAIL state
        else
          predFn env byteArr (t,nextpos,Map.insert theta path (a,(pos,width)))
     end
   | (path,Declared name)::t =>
       (case Alist.lookup decls name
         of None => FAIL state
          | Some c => predFn env byteArr ((path,c)::t,pos,theta))
   | (path,Raw exp)::t =>
       (case resolveExp theta path exp
         of None => FAIL state
          | Some exp' =>
        case evalExp (consts,theta,valFn) byteArr exp'
         of None => FAIL state
          | Some width =>
        let val nextpos = pos + width
        in if arrlen < nextpos then
              FAIL state
           else
             predFn env byteArr
              (t, nextpos, Map.insert theta path (Blob,(pos,width)))
        end)
   | (path,Assert bexp)::t =>
       (case resolveBexp theta path bexp
        of None => FAIL state
         | Some bexp' =>
        case evalBexp (consts,theta,valFn,dvalFn) byteArr bexp'
         of Some true => predFn env byteArr (t,pos,theta)
          | otherwise => FAIL state)
   | (path,Recd fields)::t =>
       predFn env byteArr (List.map (fieldFn path) fields @ t,pos,theta)
   | (path,Array c exp)::t =>
       (case resolveExp theta path exp
         of None => FAIL state
          | Some exp'=>
        case evalExp (consts,theta,valFn) byteArr exp'
         of None => FAIL state
          | Some dim =>
         predFn env byteArr
           (List.map (indexFn path c) (Utils.upto 0 (dim - 1)) @ t,pos,theta))
   | (path,Union choices)::t =>
       let fun choiceFn(bexp,c) =
             Option.mapPartial
               (evalBexp (consts,theta,valFn,dvalFn) byteArr)
               (resolveBexp theta path bexp)
       in case Utils.filterOpt choiceFn choices
           of Some[(_,c)] => predFn env byteArr ((path,c)::t,pos,theta)
            | otherwise => FAIL state
       end
end
;


fun debug env contig byteArr =
  predFn env byteArr ([(VarName"root",contig)],0,empty_lvalMap());

fun wellformed env contig byteArr =
 case predFn env byteArr ([(VarName"root",contig)],0,empty_lvalMap())
  of PASS _ => True
   | FAIL _ => False;

(*---------------------------------------------------------------------------*)
(* Parsing into the ptree type. It provides record and array structure, but  *)
(* leaves leaf elements uninterpreted.                                       *)
(*---------------------------------------------------------------------------*)

(*---------------------------------------------------------------------------*)
(* Environments:                                                             *)
(*                                                                           *)
(*   consts : maps constant names to integers                                *)
(*   decls  : maps names to previously declared contigs                      *)
(*   atomWidth : gives width info for basic types                            *)
(*   valFn  : function for computing an integer value                        *)
(*            stored at the designated location in the string.               *)
(*   dvalFn : function for computing a double value                          *)
(*            stored at the designated location in the string.               *)
(*                                                                           *)
(* parseFn operates on a state tuple (stk,s,lvmap)                           *)
(*                                                                           *)
(*  stk  : ptree list         ;;; parser stack                               *)
(*  s    : string             ;;; remainder of string                        *)
(* lvmap : (lval |-> string)  ;;; previously seen values, accessed by path   *)
(*                                                                           *)
(* which is wrapped in the error monad.                                      *)
(*---------------------------------------------------------------------------*)


fun parseFn env byteArr path contig state =
 let val (consts,decls,atomWidth,valFn,dvalFn) = env
     val (stk,pos,theta) = state
     val arrlen = Word8Array.length byteArr
 in
 case contig
  of Void => None
   | Basic a =>
       let val width = atomWidth a
           val nextpos = pos + width
       in if arrlen < nextpos then
          None
          else
           Some(LEAF a (Option.valOf (total_bytes_of byteArr pos width))::stk,
                nextpos,
                Map.insert theta path (a,(pos,width)))
       end
   | Declared name =>
       (case Alist.lookup decls name
         of None => None
          | Some c => parseFn env byteArr path c state)
   | Raw exp =>
       (case resolveExp theta path exp
         of None => None
          | Some exp' =>
        case evalExp (consts,theta,valFn) byteArr exp'
         of None => None
          | Some width =>
        let val nextpos = pos + width
        in if arrlen < nextpos then
              None
           else
            Some (LEAF Blob (Option.valOf(total_bytes_of byteArr pos width))::stk,
                  nextpos,
                  Map.insert theta path (Blob,(pos,width)))
        end)
   | Assert bexp =>
       (case resolveBexp theta path bexp
         of None => None
	  | Some  bexp' =>
         case evalBexp (consts,theta,valFn,dvalFn) byteArr bexp'
          of None => None
           | Some tval =>
         if tval then Some state
         else (print "Assertion failure"; None))
   | Recd fields =>
       let fun fieldFn field stOpt =
             let val (fName,c) = field
             in case stOpt
                 of None => None
                  | Some st => parseFn env byteArr (RecdProj path fName) c st
             end
          fun is_assert pair = (case snd pair of Assert _ => True | otherwise => False)
          val fields' = List.filter (not o is_assert) fields
       in case Utils.rev_itlist fieldFn fields (Some state)
           of None => None
            | Some (stk',pos',theta') =>
          case Utils.take_drop (List.length fields') stk'
           of None => None
            | Some(elts,stk'') =>
              Some(RECD (List.zip (List.map fst fields', List.rev elts))::stk'',
                   pos', theta')
       end
   | Array c exp =>
       let fun indexFn i stOpt =
            (case stOpt
             of None => None
              | Some st => parseFn env byteArr (ArraySub path (IntLit i)) c st)
       in case resolveExp theta path exp
           of None => None
	    | Some exp' =>
          case evalExp (consts,theta,valFn) byteArr exp'
           of None => None
            | Some dim =>
          case Utils.rev_itlist indexFn (Utils.upto 0 (dim - 1)) (Some state)
           of None => None
            | Some (stk',pos',theta') =>
          case Utils.take_drop dim stk'
           of None => None
            | Some(elts,stk'') => Some(ARRAY (List.rev elts)::stk'', pos', theta')
       end
   | Union choices =>
       let fun choiceFn(bexp,c) =
             Option.mapPartial
               (evalBexp (consts,theta,valFn,dvalFn) byteArr)
               (resolveBexp theta path bexp)
       in case Utils.filterOpt choiceFn choices
           of Some[(_,c)] => parseFn env byteArr path c state
            | otherwise => None
       end
 end
;

fun parse env contig byteArr =
 case parseFn env byteArr (VarName"root") contig ([],0,empty_lvalMap())
  of Some ([ptree],pos,theta) => (ptree,pos,theta)
   | Some otherwise => raise Utils.ERR "parse" "expected stack of size 1"
   | None => raise Utils.ERR "parse" ""
;

fun add_contig_decl (s,d) env =
 let val (consts,decls,aW,vFn,dvFn) = env
 in (consts,(s,d)::decls,aW,vFn,dvFn)
 end

(*---------------------------------------------------------------------------*)
(* Valuation functions                                                       *)
(*---------------------------------------------------------------------------*)

fun valFnBE atm bytes =
 case atm
  of Signed i   => Some (Utils.twos_compBE bytes)
   | Unsigned i => Some (Utils.unsignedBE bytes)
   | otherwise  => Some (Utils.unsignedBE bytes);

fun valFnLE atm bytes =
 case atm
  of Signed i   => Some (Utils.twos_compLE bytes)
   | Unsigned i => Some (Utils.unsignedLE bytes)
   | otherwise  => Some (Utils.unsignedLE bytes);

fun atom_string atom =
 case atom
  of Bool       => "Bool"
   | Char       => "Char"
   | Float      => "Float"
   | Double     => "Double"
   | Signed n   => "Signed"
   | Unsigned n => "Unsigned"
   | Blob       => "Blob";

(* val () = print ("dvalFnLE: value = "^Double.toString dval^"\n") *)
local
  val buf = Word8Array.array 8 (Word8.fromInt 0)
in
fun dvalFnLE atm bytes =
 case atm
  of Float =>
     let val s = String.implode (List.map Utils.w8char bytes)
         val () = Utils.clear_buf buf
         val () = #(float2doublePromote) s buf
         val a = Word8Array.sub buf 0
         val b = Word8Array.sub buf 1
         val c = Word8Array.sub buf 2
         val d = Word8Array.sub buf 3
         val e = Word8Array.sub buf 4
         val f = Word8Array.sub buf 5
         val g = Word8Array.sub buf 6
         val h = Word8Array.sub buf 7
         val dval = Word64.concatAll a b c d e f g h
     in dval
     end
   | Double =>
       (case bytes
         of [a,b,c,d,e,f,g,h] => Word64.concatAll a b c d e f g h
          | otherwise =>
            raise Utils.ERR "dvalFnLE" "expected exactly 8 bytes for a Double")
   | otherwise =>
      (Utils.println ("dvalFnLE: atm is unexpected: "^atom_string atm);
       raise Utils.ERR "dvalFnLE" "expected Float or Double")
end

(*---------------------------------------------------------------------------*)
(* decoders for basic types                                                  *)
(*---------------------------------------------------------------------------*)

fun mk_intBE ptree =
 case ptree
  of LEAF a string => Option.valOf (valFnBE a string)
   | otherwise => raise Utils.ERR "Gate_Parse.mk_int" "expected a LEAF";

fun mk_intLE ptree =
 case ptree
  of LEAF a string => Option.valOf (valFnLE a string)
   | otherwise => raise Utils.ERR "Gate_Parse.mk_int" "expected a LEAF";

fun mk_floatLE ptree =
 case ptree
  of LEAF a bytes => dvalFnLE a bytes
   | otherwise => raise Utils.ERR "Gate_Parse.mk_floatLE" "expected a LEAF";

fun mk_doubleLE ptree =
 case ptree
  of LEAF a bytes => dvalFnLE a bytes
   | otherwise => raise Utils.ERR "Gate_Parse.mk_doubleLE" "expected a LEAF";

fun mk_byte ptree =
 case ptree
  of LEAF a string => Word8.fromInt(Option.valOf (valFnBE a string))
   | otherwise => raise Utils.ERR "Gate_Parse.mk_byte" "expected a LEAF";

val mk_bool = Utils.boolVal o mk_intBE;

fun mk_raw ptree =
 case ptree
   of LEAF Blob bytes => Utils.byte_array_fromList bytes
    | otherwise => raise Utils.ERR "mk_raw" "expected a LEAF";

fun mk_string ptree =
 case ptree
  of ARRAY elts => String.implode (List.map (Char.chr o mk_intBE) elts)
   | otherwise  => raise Utils.ERR "mk_string" "";

fun mk_array eltFn ptree =
 case ptree
  of ARRAY elts => Array.fromList (List.map eltFn elts)
   | otherwise  => raise Utils.ERR "mk_array" "";

fun mk_byte_array ptree =
 case ptree
  of ARRAY elts => Utils.byte_array_fromList (List.map mk_byte elts)
   | otherwise  => raise Utils.ERR "mk_byte_array" "";

end (* ByteContig *)


structure Defs = 
struct

datatype Coordinate = Coordinate Double.double Double.double Double.double;

datatype MsgHeader = MsgHeader int int;

type AttestationRequestMsg = (int array);

type AttestationResponseMsg = (int array);

type AddressArray = (int array);

type KeepInZone = (Coordinate array);

type Map = (Coordinate array);

datatype AllowList = AllowList AddressArray;

type Mission = (Coordinate array);

datatype Command = Command Map;

datatype RF_Msg = RF_Msg MsgHeader Command;

fun proj_Latitude_Coordinate recd =
  case recd
    of Coordinate v1 v2 v3 => v1;

fun proj_Longitude_Coordinate recd =
  case recd
    of Coordinate v1 v2 v3 => v2;

fun proj_Altitude_Coordinate recd =
  case recd
    of Coordinate v1 v2 v3 => v3;

fun proj_src_MsgHeader recd =
  case recd
    of MsgHeader v1 v2 => v1;

fun proj_dst_MsgHeader recd =
  case recd
    of MsgHeader v1 v2 => v2;

fun proj_value_AllowList recd =
  case recd
    of AllowList v1 => v1;

fun proj_Map_Command recd =
  case recd
    of Command v1 => v1;

fun proj_header_RF_Msg recd =
  case recd
    of RF_Msg v1 v2 => v1;

fun proj_payload_RF_Msg recd =
  case recd
    of RF_Msg v1 v2 => v2;

val bottom_left =
   (Coordinate (Double.fromString "45.3004") 
     (Utils.double_negate(Double.fromString "121.01473")) 
     (Double.fromString "1000.0"));

val top_right =
   (Coordinate (Double.fromString "45.345315") 
     (Utils.double_negate(Double.fromString "120.91252")) 
     (Double.fromString "1000.0"));

fun is_bounded pt low high =
((Utils.double_gte pt low) andalso (Utils.double_lte pt high));

fun good_coordinate coord =
((((((Utils.double_gte (proj_Latitude_Coordinate coord) 
            (Utils.double_negate(Double.fromString "90.0")))
          andalso
          (Utils.double_lte (proj_Latitude_Coordinate coord) 
            (Double.fromString "90.0")))
        andalso
        (Utils.double_gte (proj_Longitude_Coordinate coord) 
          (Utils.double_negate(Double.fromString "180.0"))))
      andalso
      (Utils.double_lte (proj_Longitude_Coordinate coord) 
        (Double.fromString "180.0")))
    andalso
    (Utils.double_gte (proj_Altitude_Coordinate coord) 
      (Double.fromString "0.0")))
  andalso
  (Utils.double_lte (proj_Altitude_Coordinate coord) 
    (Double.fromString "15000.0")));

val max_aadlinteger = 4294967296;

val max_target_integer = 4294967296;

val max_base_address = 4294967296;

val max_memory_size = 4294967296;

val max_queue_size = 512;

val max_thread_limit = 32;

val max_time = 1000;

val max_urgency = 12;

val max_byte_count = 4294967296;

val max_word_space = 64;

val max_volume = 1000;

fun is_trusted command ids =
(Array.exists (fn i =>
    ((proj_src_MsgHeader (proj_header_RF_Msg command)) = i)) 
  (proj_value_AllowList ids));

val keep_in_zone = (Array.fromList [bottom_left,top_right]);

fun waypoint_in_zone wp kiz =
(((is_bounded (proj_Latitude_Coordinate wp) 
      (proj_Latitude_Coordinate (Array.sub kiz (1 - 1))) 
      (proj_Latitude_Coordinate (Array.sub kiz (2 - 1))))
    andalso
    (is_bounded (proj_Longitude_Coordinate wp) 
      (proj_Longitude_Coordinate (Array.sub kiz (1 - 1))) 
      (proj_Longitude_Coordinate (Array.sub kiz (2 - 1)))))
  andalso
  (is_bounded (proj_Altitude_Coordinate wp) 
    (proj_Altitude_Coordinate (Array.sub kiz (1 - 1))) 
    (proj_Altitude_Coordinate (Array.sub kiz (2 - 1)))));

fun good_map map = (Array.all (fn wp => (good_coordinate wp)) map);

fun waypoints_in_zone plan kiz =
(Array.all (fn i => (waypoint_in_zone i kiz)) plan);

fun good_command cmd = (good_map (proj_Map_Command cmd));

fun well_formed_message msg = (good_command (proj_payload_RF_Msg msg));

fun well_formed_mission_command msg =
(good_command (proj_payload_RF_Msg msg));

end


structure Parse = 
struct

(*---------------------------------------------------------------------------*)
(* Set up parsing environment                                                *)
(*---------------------------------------------------------------------------*)


fun atom_width atom =
 case atom
  of ByteContig.Bool       => 1
   | ByteContig.Char       => 1
   | ByteContig.Float      => 4
   | ByteContig.Double     => 8
   | ByteContig.Signed n   => n
   | ByteContig.Unsigned n => n
   | other => raise Utils.ERR "atomic_width" "Blob: unknown width"


val parseEnv =
  ([],[],atom_width,ByteContig.valFnLE,ByteContig.dvalFnLE);


fun is_event byteA =
  0 < Word8Array.length byteA andalso
  Word8Array.sub byteA 0 = Word8.fromInt 1;


fun eventParse p byteA =
 if not(is_event byteA) then
    None
 else
  let val (contig,mk_data) = p
  in case ByteContig.parseFn
            parseEnv byteA (ByteContig.VarName"root") contig
              ([],1,ByteContig.empty_lvalMap())
      of Some([ptree],_,_) => Some (Utils.total mk_data ptree)
       | otherwise => Some None
  end;


(*---------------------------------------------------------------------------*)
(* Contig stuff                                                              *)
(*---------------------------------------------------------------------------*)


fun intLit i   = ByteContig.IntLit i;
fun unsigned n = ByteContig.Basic(ByteContig.Unsigned n);
fun signed n   = ByteContig.Basic(ByteContig.Signed n);
fun mk_Array c n = ByteContig.Array c (intLit n);
fun mk_Recd list   = ByteContig.Recd list;
fun mk_Union list  = ByteContig.Union list;


val bool = ByteContig.Basic ByteContig.Bool;
val u8   = unsigned 1;
val char = unsigned 1;
val u16  = unsigned 2;
val u32  = unsigned 4;
val u64  = unsigned 8;
val i16  = signed 2;
val i32  = signed 4;
val i64  = signed 8;
val f32  = ByteContig.Basic(ByteContig.Float);
val f64  = ByteContig.Basic(ByteContig.Double);

val contig_Coordinate =
   (mk_Recd [("Latitude",f32),("Longitude",f32),("Altitude",f32)]);

val contig_MsgHeader = (mk_Recd [("src",u32),("dst",u32)]);

val contig_AttestationRequestMsg = (mk_Array u8 16);

val contig_AttestationResponseMsg = (mk_Array u8 2048);

val contig_AddressArray = (mk_Array u32 4);

val contig_KeepInZone =
   (mk_Array (mk_Recd [("Latitude",f32),("Longitude",f32),("Altitude",f32)])
     2);

val contig_Map =
   (mk_Array (mk_Recd [("Latitude",f32),("Longitude",f32),("Altitude",f32)])
     2);

val contig_AllowList = (mk_Recd [("value",(mk_Array u32 4))]);

val contig_Mission =
   (mk_Array (mk_Recd [("Latitude",f32),("Longitude",f32),("Altitude",f32)])
     3);

val contig_Command =
   (mk_Recd [("Map",
      (mk_Array (mk_Recd [("Latitude",f32),("Longitude",f32),
          ("Altitude",f32)]) 2))]);

val contig_RF_Msg =
   (mk_Recd [("header",(mk_Recd [("src",u32),("dst",u32)])),
     ("payload",
      (mk_Recd [("Map",
         (mk_Array (mk_Recd [("Latitude",f32),("Longitude",f32),
             ("Altitude",f32)]) 2))]))]);

val mk_intLE   = ByteContig.mk_intLE;
val mk_floatLE = ByteContig.mk_floatLE;
val mk_array   = ByteContig.mk_array;

fun decode_Coordinate ptree =
case ptree
   of (ByteContig.RECD [v1,v2,v3]) =>
      (Defs.Coordinate (mk_floatLE (snd v1)) (mk_floatLE (snd v2)) 
        (mk_floatLE (snd v3)))
    | otherwise =>
      raise Utils.ERR
        "decode_Coordinate"
        "unexpected parse tree";

fun decode_MsgHeader ptree =
case ptree
   of (ByteContig.RECD [v1,v2]) =>
      (Defs.MsgHeader (mk_intLE (snd v1)) (mk_intLE (snd v2)))
    | otherwise =>
      raise Utils.ERR
        "decode_MsgHeader"
        "unexpected parse tree";

val decode_AttestationRequestMsg = (mk_array mk_intLE);

val decode_AttestationResponseMsg = (mk_array mk_intLE);

val decode_AddressArray = (mk_array mk_intLE);

val decode_KeepInZone = (mk_array decode_Coordinate);

val decode_Map = (mk_array decode_Coordinate);

fun decode_AllowList ptree =
case ptree
   of (ByteContig.RECD [v1]) =>
      (Defs.AllowList ((mk_array mk_intLE) (snd v1)))
    | otherwise =>
      raise Utils.ERR
        "decode_AllowList"
        "unexpected parse tree";

val decode_Mission = (mk_array decode_Coordinate);

fun decode_Command ptree =
case ptree
   of (ByteContig.RECD [v1]) =>
      (Defs.Command ((mk_array decode_Coordinate) (snd v1)))
    | otherwise =>
      raise Utils.ERR
        "decode_Command"
        "unexpected parse tree";

fun decode_RF_Msg ptree =
case ptree
   of (ByteContig.RECD [v1,v2]) =>
      (Defs.RF_Msg (decode_MsgHeader (snd v1)) (decode_Command (snd v2)))
    | otherwise =>
      raise Utils.ERR
        "decode_RF_Msg"
        "unexpected parse tree";

val parse_RF_Msg = (eventParse (contig_RF_Msg,decode_RF_Msg));

val parse_AllowList = (eventParse (contig_AllowList,decode_AllowList));

end


structure API = 
struct

val missioncommand_in_buffer = Word8Array.array 33 Utils.w8zero;

val trustedids_buffer = Word8Array.array 17 Utils.w8zero;

fun fill_missioncommand_in_buffer () = 
  let val () = Utils.clear_buf missioncommand_in_buffer
  in #(api_get_MissionCommand_in) "" missioncommand_in_buffer
  end;

fun fill_trustedids_buffer () = 
  let val () = Utils.clear_buf trustedids_buffer
  in #(api_get_TrustedIds) "" trustedids_buffer
  end;

fun send_missioncommand_out string = #(api_send_MissionCommand_out) string Utils.emptybuf;

fun logInfo s = #(api_logInfo) s Utils.emptybuf;

end


structure Gadget = 
struct

fun pre x = x;
val valOf = Option.valOf;

val initState = None : Defs.AllowList option;
val theState = Ref initState;
val initStep = Ref True;

fun stepFn inputs stateVars = 
  let val (missioncommand_in,trustedids) = inputs
      
      val trusted_ids = stateVars
      
      val event_missioncommand_in = (Option.isSome missioncommand_in)
      
      val event_trustedids = (Option.isSome trustedids)
      
      (*--------------------------*)
      (* Compute new state values *)
      (*--------------------------*)
      
      val newStateVars =
        if !initStep
        then
        let val trusted_ids =
              if event_trustedids then
                (valOf trustedids)
                else (Defs.AllowList (Array.fromList [0,0,0,0]))
            
            val () = (initStep := False)
        in
          trusted_ids
        end
        else
        let val trusted_ids = (valOf trusted_ids)
            
            val trusted_ids =
              if event_trustedids then
                (valOf trustedids)
                else (pre trusted_ids)
        in
          trusted_ids
        end
      val trusted_ids = newStateVars
      val newStateVarOpts = (Some trusted_ids)
      
      (*-----------------------*)
      (* Compute output values *)
      (*-----------------------*)
      
      val missioncommand_out =
        if (event_missioncommand_in
            andalso
            (Defs.is_trusted (valOf missioncommand_in) trusted_ids)) then
          (Some (valOf missioncommand_in))
          else None
  in
     (newStateVarOpts,missioncommand_out)
  end

fun parse_missioncommand_in () =
  let val () = API.fill_missioncommand_in_buffer ()
      val inOpt2 = Parse.parse_RF_Msg API.missioncommand_in_buffer
  in
     Utils.dropOpt "Parsing of missioncommand_inport failed." inOpt2
  end;

fun parse_trustedids () =
  let val () = API.fill_trustedids_buffer ()
      val inOpt2 = Parse.parse_AllowList API.trustedids_buffer
  in
     Utils.dropOpt "Parsing of trustedidsport failed." inOpt2
  end;

fun gadgetFn() = 
  let val missioncommand_inOpt = parse_missioncommand_in ()
      val trustedidsOpt = parse_trustedids ()
      val inputs = (missioncommand_inOpt,trustedidsOpt)
      val (newState,outputs) = stepFn inputs (!theState)
      val () = (theState := newState)
      val missioncommand_out = outputs
  in
    case missioncommand_out
     of None => ()
      | Some _ => 
        let val len = Word8Array.length API.missioncommand_in_buffer
        in API.send_missioncommand_out
              (Word8Array.substring API.missioncommand_in_buffer 1 (len-1))
        end
  end
  handle _ => (API.logInfo "gadgetFn: exception raised (and caught); continuing"; ());

end


structure Control =
struct

fun pacer_emit() =
    (#(sb_pacer_notification_emit) "" Utils.singlebuf;
     Word8Array.sub Utils.singlebuf 0 <> Word8.fromInt 0);

fun pacer_wait() =
    (#(sb_pacer_notification_wait) "" Utils.singlebuf;
     Word8Array.sub Utils.singlebuf 0 <> Word8.fromInt 0);

fun receiveInput() = #(api_receiveInput) "" Utils.emptybuf;
fun sendOutput()   = #(api_sendOutput) "" Utils.emptybuf;

fun loop () =
  if pacer_wait() then
    ( receiveInput();
      Gadget.gadgetFn();
      sendOutput();
      pacer_emit();
      loop()
    )
  else
    loop();

fun start () = (pacer_emit(); loop());

end (* Control *)

val _ = Control.start();


